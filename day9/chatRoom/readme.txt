客户端client
登录
    序列化结构体,发送给服务端,通过网络读写proto的写操作
                      服务端拿到请求,启动goroute处理请求,通过conn去网络读写的读操作,读取数据
                      客户端发过来一个登录包,这里就读到一个登录包,通过标识就知道是登录,注册还是发送消息

    通过一个switch判断标识是什么请求,然后去实现对应的逻辑
    实现登录,拿到data数据,反序列化成登录的结构体,然后校验逻辑,处理完了,把数据再通过proto写出,客户端就可以读取到数据

    客户端是单独启动一个go read() 去读取数据
        read函数,从proto函数读取一个包,判断是什么登录返回/注册返回/发送消息返回
        然后反序列化成结构体,然后把登录返回结构体放到chanel中,给主线程,(主线程一直在等待,在login()之后,一直在等待channel返回)
        这个chanel是空interface{} 需要转换成具体的类型,转换成功校验标识是不是成功errno
        登录成功,就进入一个for循环,用户可以发送消息
            通过bufio读取数据,发送给服务端
            填充到结构体,序列化之后,通过proto发送消息
        服务端发现是发送消息请求
        经过switch,判断是不是发送消息的请求
            如果是发送消息,需要广播出去
            消息放入clientMgr.Aadd
            不断遍历管道中的消息,有消息就立刻广播出去
            遍历当前连接的map
            一个个发送消息
